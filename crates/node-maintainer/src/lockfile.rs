use std::collections::HashMap;

use kdl::{KdlDocument, KdlNode};
use nassun::PackageResolution;
use node_semver::Version;
use oro_package_spec::PackageSpec;
use ssri::Integrity;
use unicase::UniCase;

use crate::DepType;

#[derive(Debug, Clone)]
pub struct Lockfile {
    pub version: u64,
    pub root: Pkg,
    pub packages: Vec<Pkg>,
}

impl Lockfile {
    pub fn to_kdl(&self) -> KdlDocument {
        let mut doc = KdlDocument::new();
        doc.set_leading(
            "// This file is automatically generated and not intended for manual editing.",
        );
        let mut version_node = KdlNode::new("lockfile-version");
        version_node.push(1);
        doc.nodes_mut().push(version_node);
        doc.nodes_mut().push(self.root.to_kdl());
        for pkg in &self.packages {
            doc.nodes_mut().push(pkg.to_kdl());
        }
        doc.fmt();
        doc
    }
}

#[derive(Debug, Clone)]
pub struct Pkg {
    pub name: UniCase<String>,
    pub is_root: bool,
    pub path: Vec<UniCase<String>>,
    pub resolved: Option<PackageResolution>,
    pub version: Option<Version>,
    pub integrity: Option<Integrity>,
    pub dependencies: HashMap<UniCase<String>, PackageSpec>,
    pub dev_dependencies: HashMap<UniCase<String>, PackageSpec>,
    pub peer_dependencies: HashMap<UniCase<String>, PackageSpec>,
    pub optional_dependencies: HashMap<UniCase<String>, PackageSpec>,
}

impl Pkg {
    fn to_kdl(&self) -> KdlNode {
        let mut kdl_node = if self.is_root {
            KdlNode::new("root")
        } else {
            KdlNode::new("pkg")
        };
        for name in &self.path {
            kdl_node.push(name.as_ref());
        }
        if let Some(resolved) = &self.resolved {
            if let &PackageResolution::Npm { version, .. } = &resolved {
                let mut vnode = KdlNode::new("version");
                vnode.push(version.to_string());
                kdl_node.ensure_children().nodes_mut().push(vnode);
            }
            if !self.is_root {
                let mut rnode = KdlNode::new("resolved");
                rnode.push(resolved.to_string());
                kdl_node.ensure_children().nodes_mut().push(rnode);

                if let &PackageResolution::Npm {
                    integrity: Some(i), ..
                } = &resolved
                {
                    let mut inode = KdlNode::new("integrity");
                    inode.push(i.to_string());
                    kdl_node.ensure_children().nodes_mut().push(inode);
                }
            }
        }
        if !self.dependencies.is_empty() {
            kdl_node
                .ensure_children()
                .nodes_mut()
                .push(self.kdl_deps(&DepType::Prod, &self.dependencies));
        }
        if !self.dev_dependencies.is_empty() {
            kdl_node
                .ensure_children()
                .nodes_mut()
                .push(self.kdl_deps(&DepType::Dev, &self.dev_dependencies));
        }
        if !self.peer_dependencies.is_empty() {
            kdl_node
                .ensure_children()
                .nodes_mut()
                .push(self.kdl_deps(&DepType::Peer, &self.peer_dependencies));
        }
        if !self.optional_dependencies.is_empty() {
            kdl_node
                .ensure_children()
                .nodes_mut()
                .push(self.kdl_deps(&DepType::Opt, &self.optional_dependencies));
        }
        kdl_node
    }

    fn kdl_deps(
        &self,
        dep_type: &DepType,
        deps: &HashMap<UniCase<String>, PackageSpec>,
    ) -> KdlNode {
        use DepType::*;
        let type_name = match dep_type {
            Prod => "dependencies",
            Dev => "devDependencies",
            Peer => "peerDependencies",
            Opt => "optionalDependencies",
        };
        let mut deps_node = KdlNode::new(type_name);
        for (name, requested) in deps {
            let children = deps_node.ensure_children();
            let mut ddnode = KdlNode::new(name.to_string());
            ddnode.push(requested.requested());
            children.nodes_mut().push(ddnode);
        }
        deps_node
            .ensure_children()
            .nodes_mut()
            .sort_by_key(|n| n.name().to_string());
        deps_node
    }
}
