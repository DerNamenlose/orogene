use std::collections::HashMap;

use kdl::{KdlDocument, KdlNode};
use nassun::{Nassun, PackageResolution};
use node_semver::Version;
use oro_package_spec::PackageSpec;
use petgraph::stable_graph::NodeIndex;
use ssri::Integrity;
use unicase::UniCase;
use url::Url;

use crate::{DepType, Graph, IntoKdl, Node, NodeMaintainerError, ResolvedMetadata};

/// A representation of a resolved lockfile.
#[derive(Default, Debug, Clone, PartialEq, Eq)]
pub struct Lockfile {
    pub version: u64,
    pub root: LockfileNode,
    pub packages: Vec<LockfileNode>,
}

impl Lockfile {
    pub(crate) async fn into_graph(self, nassun: &Nassun) -> Result<Graph, NodeMaintainerError> {
        let mut graph = Graph::default();
        let root_idx = self.root.to_graph_node(&mut graph, nassun).await?;
        graph.root = root_idx;
        // Place all the packages in the tree, by their logical filesystem
        // location, without hooking up the dependency graph itself (yet).
        for pkg in &self.packages {
            let idx = pkg.to_graph_node(&mut graph, nassun).await?;
            self.place_child(&mut graph, idx)?;
        }
        // TODO
        // self.resolve_dependencies(&mut graph)?;
        Ok(graph)
    }

    fn place_child(&self, graph: &mut Graph, child: NodeIndex) -> Result<(), NodeMaintainerError> {
        if self.is_placed(graph, child) {
            return Ok(());
        }

        let is_toplevel = graph[child].resolved_metadata.path.len() == 1;
        if is_toplevel {
            let name = graph[child].resolved_metadata.name.clone();
            let root_idx = graph.root;
            graph[root_idx].children.insert(name, child);
        }
        Ok(())
    }

    fn is_placed(&self, graph: &mut Graph, child: NodeIndex) -> bool {
        let path = &graph[child].resolved_metadata.path;
        let mut current = graph.inner.node_weight(graph.root);
        for segment in path {
            if let Some(current_node) = current {
                current = current_node
                    .children
                    .get(&segment)
                    .and_then(|idx| graph.inner.node_weight(*idx));
            } else {
                break;
            }
        }
        current.is_some()
    }

    pub fn to_kdl(&self) -> KdlDocument {
        let mut doc = KdlDocument::new();
        doc.set_leading(
            "// This file is automatically generated and not intended for manual editing.",
        );
        let mut version_node = KdlNode::new("lockfile-version");
        version_node.push(self.version as i64);
        doc.nodes_mut().push(version_node);
        doc.nodes_mut().push(self.root.to_kdl());
        for pkg in &self.packages {
            doc.nodes_mut().push(pkg.to_kdl());
        }
        doc.fmt();
        doc
    }

    pub fn from_kdl(kdl: impl IntoKdl) -> Result<Self, NodeMaintainerError> {
        let kdl: KdlDocument = kdl.into_kdl()?;
        fn inner(kdl: KdlDocument) -> Result<Lockfile, NodeMaintainerError> {
            Ok(Lockfile {
                version: kdl
                    .get_arg("lockfile-version")
                    .and_then(|v| v.as_i64())
                    .map(|v| v.try_into())
                    .transpose()
                    // TODO: add a miette span here
                    .map_err(|_| NodeMaintainerError::InvalidLockfileVersion)?
                    .unwrap_or(1),
                root: kdl
                    .get("root")
                    // TODO: add a miette span here
                    .ok_or_else(|| NodeMaintainerError::MissingRoot(kdl.clone()))
                    .and_then(|node| LockfileNode::from_kdl(node, true))?,
                packages: kdl
                    .nodes()
                    .into_iter()
                    .filter(|node| node.name().to_string() == "pkg")
                    .map(|node| LockfileNode::from_kdl(node, false))
                    .collect::<Result<Vec<LockfileNode>, NodeMaintainerError>>()?,
            })
        }
        inner(kdl)
    }
}

#[derive(Default, Debug, Clone, PartialEq, Eq)]
pub struct LockfileNode {
    pub name: UniCase<String>,
    pub is_root: bool,
    pub path: Vec<UniCase<String>>,
    pub resolved: Option<Url>,
    pub version: Option<Version>,
    pub integrity: Option<Integrity>,
    pub dependencies: HashMap<UniCase<String>, PackageSpec>,
    pub dev_dependencies: HashMap<UniCase<String>, PackageSpec>,
    pub peer_dependencies: HashMap<UniCase<String>, PackageSpec>,
    pub optional_dependencies: HashMap<UniCase<String>, PackageSpec>,
}

impl LockfileNode {
    async fn to_graph_node(
        &self,
        graph: &mut Graph,
        nassun: &Nassun,
    ) -> Result<NodeIndex, NodeMaintainerError> {
        let version = if let Some(ref version) = self.version {
            version
        } else {
            return Err(NodeMaintainerError::MissingVersion);
        };
        let spec: PackageSpec = format!("{}@{version}", self.name).parse()?;
        let package = match &spec.target() {
            PackageSpec::Dir { path } => {
                let resolution = PackageResolution::Dir {
                    name: self.name.to_string(),
                    path: path.clone(),
                };
                nassun.resolve_from(self.name.to_string(), spec, resolution)
            }
            PackageSpec::Npm { scope, name, .. } => {
                if let Some(ref url) = self.resolved {
                    let resolution = PackageResolution::Npm {
                        name: if let Some(scope) = scope {
                            format!("{scope}@{name}")
                        } else {
                            name.to_string()
                        },
                        version: version.clone(),
                        tarball: url.clone(),
                        integrity: self.integrity.clone(),
                    };
                    nassun.resolve_from(self.name.to_string(), spec, resolution)
                } else {
                    nassun.resolve(spec.to_string()).await?
                }
            }
            PackageSpec::Git(info) => {
                if info.committish().is_some() {
                    let resolution = PackageResolution::Git {
                        name: self.name.to_string(),
                        info: info.clone(),
                    };
                    nassun.resolve_from(self.name.to_string(), spec, resolution)
                } else {
                    nassun.resolve(spec.to_string()).await?
                }
            }
            PackageSpec::Alias { .. } => {
                unreachable!("Alias should have already been resolved by the .target() call above.")
            }
        };
        let resolved_metadata = ResolvedMetadata {
            name: self.name.clone(),
            path: self.path.clone(),
            version: self.version.clone(),
            resolved: self.resolved.clone(),
            dependencies: self.dependencies.clone(),
            dev_dependencies: self.dev_dependencies.clone(),
            peer_dependencies: self.peer_dependencies.clone(),
            optional_dependencies: self.optional_dependencies.clone(),
            integrity: self.integrity.clone(),
        };
        let idx = graph.inner.add_node(Node::new(package));
        let node = &mut graph.inner[idx];
        node.idx = idx;
        node.resolved_metadata = resolved_metadata;
        Ok(idx)
    }

    fn from_kdl(node: &KdlNode, is_root: bool) -> Result<Self, NodeMaintainerError> {
        let children = node.children().cloned().unwrap_or_else(KdlDocument::new);
        let path = node
            .entries()
            .iter()
            .filter(|e| e.name().is_none() && e.value().is_base10())
            .map(|e| UniCase::new(e.value().to_string()))
            .collect::<Vec<_>>();
        let name = children
            .get_arg("name")
            .cloned()
            .map(|val| UniCase::new(val.to_string()))
            .or_else(|| {
                let len = path.len();
                if len > 1 && path[len - 2].starts_with("@") {
                    Some(UniCase::new(format!("{}@{}", path[len - 2], path[len - 1])))
                } else {
                    path.last().cloned()
                }
            })
            // TODO: add a miette span here
            .ok_or_else(|| NodeMaintainerError::MissingName(node.clone()))?;
        let integrity = children
            .get_arg("integrity")
            .map(|i| i.to_string().parse())
            .transpose()?;
        let version = children
            .get_arg("version")
            .map(|val| {
                val.to_string()
                    .parse()
                    // TODO: add a miette span here
                    .map_err(NodeMaintainerError::SemverParseError)
            })
            .transpose()?;
        let resolved = children
            .get_arg("resolved")
            .map(|resolved| -> Result<Url, NodeMaintainerError> {
                Ok(resolved.to_string().parse()?)
            })
            .transpose()?;
        Ok(Self {
            name,
            is_root,
            path,
            integrity,
            resolved,
            version,
            dependencies: Self::from_kdl_deps(&children, &DepType::Prod)?,
            dev_dependencies: Self::from_kdl_deps(&children, &DepType::Dev)?,
            optional_dependencies: Self::from_kdl_deps(&children, &DepType::Opt)?,
            peer_dependencies: Self::from_kdl_deps(&children, &DepType::Peer)?,
        })
    }

    fn from_kdl_deps(
        children: &KdlDocument,
        dep_type: &DepType,
    ) -> Result<HashMap<UniCase<String>, PackageSpec>, NodeMaintainerError> {
        use DepType::*;
        let type_name = match dep_type {
            Prod => "dependencies",
            Dev => "dev-dependencies",
            Peer => "peer-dependencies",
            Opt => "optional-dependencies",
        };
        let mut deps = HashMap::new();
        if let Some(node) = children.get(type_name) {
            if let Some(children) = node.children() {
                for dep in children.nodes() {
                    let name = UniCase::new(dep.name().to_string());
                    let spec = dep
                        .get(0)
                        .map(|spec| spec.to_string())
                        .unwrap_or_else(|| "*".to_string());
                    deps.insert(name, spec.parse()?);
                }
            }
        }
        Ok(deps)
    }

    fn to_kdl(&self) -> KdlNode {
        let mut kdl_node = if self.is_root {
            KdlNode::new("root")
        } else {
            KdlNode::new("pkg")
        };
        for name in &self.path {
            kdl_node.push(name.as_ref());
        }
        if let Some(ref version) = self.version {
            let mut vnode = KdlNode::new("version");
            vnode.push(version.to_string());
            kdl_node.ensure_children().nodes_mut().push(vnode);
        }
        if let Some(resolved) = &self.resolved {
            if !self.is_root {
                let mut rnode = KdlNode::new("resolved");
                rnode.push(resolved.to_string());
                kdl_node.ensure_children().nodes_mut().push(rnode);

                if let Some(integrity) = &self.integrity {
                    let mut inode = KdlNode::new("integrity");
                    inode.push(integrity.to_string());
                    kdl_node.ensure_children().nodes_mut().push(inode);
                }
            }
        }
        if !self.dependencies.is_empty() {
            kdl_node
                .ensure_children()
                .nodes_mut()
                .push(self.to_kdl_deps(&DepType::Prod, &self.dependencies));
        }
        if !self.dev_dependencies.is_empty() {
            kdl_node
                .ensure_children()
                .nodes_mut()
                .push(self.to_kdl_deps(&DepType::Dev, &self.dev_dependencies));
        }
        if !self.peer_dependencies.is_empty() {
            kdl_node
                .ensure_children()
                .nodes_mut()
                .push(self.to_kdl_deps(&DepType::Peer, &self.peer_dependencies));
        }
        if !self.optional_dependencies.is_empty() {
            kdl_node
                .ensure_children()
                .nodes_mut()
                .push(self.to_kdl_deps(&DepType::Opt, &self.optional_dependencies));
        }
        kdl_node
    }

    fn to_kdl_deps(
        &self,
        dep_type: &DepType,
        deps: &HashMap<UniCase<String>, PackageSpec>,
    ) -> KdlNode {
        use DepType::*;
        let type_name = match dep_type {
            Prod => "dependencies",
            Dev => "dev-dependencies",
            Peer => "peer-dependencies",
            Opt => "optional-dependencies",
        };
        let mut deps_node = KdlNode::new(type_name);
        for (name, requested) in deps {
            let children = deps_node.ensure_children();
            let mut ddnode = KdlNode::new(name.to_string());
            ddnode.push(requested.requested());
            children.nodes_mut().push(ddnode);
        }
        deps_node
            .ensure_children()
            .nodes_mut()
            .sort_by_key(|n| n.name().to_string());
        deps_node
    }
}
